# dockerfile

### 1.什么是dockersfile

Dockerfile 是一个文本文件，它包含了一系列的指令和配置，用于定义和构建 Docker 镜像的过程。

想象一下，如果 Docker 镜像是一座建筑物，那么 Dockerfile 就是建筑的施工图。它告诉 Docker 引擎如何从头开始构建镜像，包括哪些组件、文件和配置需要包含在镜像中。

### 2.dockerfile的构建过程

Dockerfile 的构建过程是通过 Docker 引擎按照文件中的指令逐步执行来完成的。以下是 Dockerfile 的构建过程的基本步骤：

1. 准备 Dockerfile：首先，您需要创建一个名为 Dockerfile 的文本文件，并在其中编写构建镜像所需的指令和配置。

2. 构建命令：使用 `docker build` 命令来执行 Dockerfile 的构建过程。构建命令的基本语法如下：docker build [选项] <上下文路径/URL/->
   示例:
   
   ```shell
   docker build -f dockerfile -t myimage:1.0 .
   -f: dockerfile的文件地址
   
   -t: 给这个镜像起个名字和版本标签
   
   . : 指定上下文为当前目录
   
   #至于为什么会有最后面的这个点，其实原理如下，一开始我也以为是用来指定dockerfile
   #文件在哪用的，但是看到-f参数都能明确指定dockerfile的位置了，还要.干什么，其实
   #docker在运行的时候是分为docker引擎（服务器守护进程）和客户端工具，在我们平时
   #使用的docker命令其实都是使用客户端与docker引擎在交互，那么我们在使用docker build
   #命令的时候，其实构建过程是在docker引擎上完成的，那么如果dockerfile中使用
   #COPY等操作的时候怎么让docker引擎获得这些文件呢？所有这里就有了上下文，在构建的时候
   #docker会把用户指定的上下文环境一起打包发给docker引擎，这样docker引擎就可以找到文件了
   #如果COPY的内容不在上下文环境中，docker引擎就找不到了，就会报错
   ```

3. 上下文路径：构建命令中的上下文路径指定了 Docker 引擎在构建过程中查找文件和目录的位置。Docker 引擎将该路径作为构建上下文，并在构建过程中将其发送到 Docker 守护进程。

4. 解析 Dockerfile：Docker 引擎接收构建命令后，会读取 Dockerfile，并解析其中的指令。根据指令的顺序，引擎执行相应的操作。

5. 缓存和镜像层：Docker 引擎在构建过程中使用了一种称为“镜像层”的概念。每个 Dockerfile 指令都会生成一个新的镜像层。如果前面的指令和上下文没有发生变化，Docker 会尝试使用缓存的镜像层，以加快构建速度。

6. 执行指令：Docker 引擎按照 Dockerfile 中的指令顺序逐个执行。这些指令可以包括选择基础镜像、复制文件、运行命令、设置环境变量、暴露端口等。

7. 构建镜像：在执行完所有指令后，Docker 引擎将根据最终的镜像层构建一个新的镜像。该镜像将包含了 Dockerfile 中定义的所有配置和操作。

8. 完成构建：当构建过程完成后，Docker 引擎会生成一个唯一的镜像 ID，并将其保存到本地的镜像存储中。

9. 使用构建的镜像：您可以使用构建完成的镜像来创建和运行容器，或将其推送到 Docker 仓库以供其他人使用。

### 3.dockerfile的常用指令

1. FROM：指定基础镜像。
   
   - 使用场景：选择适合您应用程序的基础镜像，例如官方的 Ubuntu、Alpine、Python、Node.js 等。
   - 示例：`FROM ubuntu:latest`

2. RUN：在镜像中执行命令。
   
   - 使用场景：安装软件包、更新系统、配置环境等。
   - 示例：`RUN apt-get update && apt-get install -y python3`

3. COPY / ADD：将文件或目录复制到镜像中。
   
   - 使用场景：将应用程序代码、配置文件、静态资源等复制到镜像中。
   - 示例：`COPY app.py /app`

4. WORKDIR：设置工作目录。
   
   - 使用场景：在容器中运行命令时，指定所在的工作目录。
   - 示例：`WORKDIR /app`

5. ENV：设置环境变量。
   
   - 使用场景：配置应用程序所需的环境变量。
   - 示例：`ENV PORT=80`

6. EXPOSE：声明容器监听的端口。
   
   - 使用场景：声明容器内部应用程序暴露的端口。
   - 示例：`EXPOSE 8080`

7. CMD：容器启动时执行的命令。
   
   - 使用场景：指定容器启动后要运行的主要命令。
   - 示例：`CMD ["python3", "app.py"]`

8. ENTRYPOINT：容器启动时执行的命令（与 CMD 一起使用）。
   
   - 使用场景：指定容器启动后要运行的主要命令，并可以与 CMD 结合使用来提供默认参数。
   - 示例：`ENTRYPOINT ["python3", "app.py"]`
   
   `CMD` 和 `ENTRYPOINT` 是 Dockerfile 中用于指定容器启动时要执行的命令的指令，它们有一些区别和不同的使用方式。
   
   ```
   CMD 指令：
   
   - CMD 指令用于指定容器启动时要执行的命令。它可以有三种不同的形式：
   
     - CMD ["executable","param1","param2"]（exec 形式）：推荐使用的形式，将命令及其参数作为 JSON 数组提供。
     - CMD command param1 param2（shell 形式）：以 shell 的方式执行命令。
     - CMD command param1 && command param2：以 shell 的方式执行多个命令。
   
   - 如果 Dockerfile 中只有一个 CMD 指令，那么它将作为容器启动时的默认命令。如果 Dockerfile 中有多个 CMD 指令，则只有最后一个 CMD 指令会生效。
   
   - 示例：
   
     `CMD ["ls", "-a"]`：使用 exec 形式，指定容器启动时要执行的命令为 `ls-a`。
   
     但我在启动时追加命令，docker run xxx -l,此时-l命令会覆盖ls -a命令不会有任何操作
   ```
   
   ENTRYPOINT 指令：
- ENTRYPOINT 指令用于指定容器启动时要执行的命令，并且不可被覆盖。它可以有两种不同的形式：
  
  - ENTRYPOINT ["executable", "param1", "param2"]（exec 形式）：推荐使用的形式，将命令及其参数作为 JSON 数组提供。
  - ENTRYPOINT command param1 param2（shell 形式）：以 shell 的方式执行命令。

- 如果 Dockerfile 中只有一个 ENTRYPOINT 指令，那么它将作为容器启动时的默认命令。如果 Dockerfile 中有多个 ENTRYPOINT 指令，则只有最后一个 ENTRYPOINT 指令会生效。

- 与 CMD 不同，ENTRYPOINT 指令的命令部分不会被覆盖，而是可以通过 Docker 命令行的参数来传递额外的参数。

- 示例：
  
  `ENTRYPOINT ["ls", "-a"]`：使用 exec 形式，指定容器启动时要执行的命令为 `ls-a`。但是我们追加一个命令，docker  run xxx -l ，此时命令不会覆盖而是追加成了ls -al，会正常执行。
  
  ```
  
  ```
9. MAINTAINER：指定镜像的作者和联系信息。
   
   - 使用场景：在镜像的元数据中添加作者和联系信息。
   - 示例：`MAINTAINER John Smith <john@example.com>`

10. VOLUME：声明持久化数据的挂载点。
    
    - 使用场景：指定容器中的路径作为数据卷，用于持久化存储数据。
    - 示例：`VOLUME /data`

11. ONBUILD：定义触发器指令，该指令将在后续镜像的构建过程中执行。
    
    - 使用场景：用于定义构建过程中的触发操作，当创建新的镜像时，这些操作会在基础镜像构建完成后被执行。
    - 示例：`ONBUILD COPY . /app`

### 4.测试实战

使用 Dockerfile 构建镜像的一般方法如下：

1. 创建一个空白的文本文件，并将其命名为 Dockerfile。
2. 在 Dockerfile 中编写指令和配置。
3. 使用 `docker build` 命令执行 Dockerfile 的构建过程，指定上下文路径和其他选项。
4. Docker 引擎按照 Dockerfile 中的指令逐步执行构建过程，并生成一个新的镜像。
5. 使用构建完成的镜像来创建和运行容器，或将其推送到 Docker 仓库。

实例1：一般我们下载的centos是阉割版的，少了很多命令，我们可以把他补上来创建一个自己的centos

dockerfile：

```shell
FROM centos:7                                                                                                                            
MAINTAINER bin<123456@qq.com>
ENV MYPATH /usr/local
WORKDIR $MYPATH
RUN yum -y inall vim
RUN yum -y install net-tools
EXPOSE 80

CMD echo $MYPATH
CMD echo "---------------------build end-----------------------"
CMD /bin/bash
```

然后用docker build来构建镜像
最后docker run -it 来测试运行

```shell
[root@mantouCentOS7 dockerfiletest]# docker run -it my_centos:1.0 /bin/bash
[root@b2181db5ebc1 local]# pwd
/usr/local
[root@b2181db5ebc1 local]# ifconfig
eth0: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500
        inet 172.17.0.2  netmask 255.255.0.0  broadcast 172.17.255.255
        ether 02:42:ac:11:00:02  txqueuelen 0  (Ethernet)
        RX packets 8  bytes 656 (656.0 B)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 0  bytes 0 (0.0 B)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0

lo: flags=73<UP,LOOPBACK,RUNNING>  mtu 65536
        inet 127.0.0.1  netmask 255.0.0.0
        inet6 ::1  prefixlen 128  scopeid 0x10<host>
        loop  txqueuelen 1000  (Local Loopback)
        RX packets 0  bytes 0 (0.0 B)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 0  bytes 0 (0.0 B)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0
```

可以看到我们添加的命令ifconfig已经成功运行，进去的工作目录也是我们设置好的 /usr/local

我们还可以用`docker history [镜像名/id]`来看这个镜像的构建过程

```shell
[root@mantouCentOS7 dockerfiletest]# docker history my_centos:1.0
IMAGE          CREATED         CREATED BY                                       SIZE      COMMENT
96c11f2a6775   8 minutes ago   CMD ["/bin/sh" "-c" "/bin/bash"]                 0B        buildkit.dockerfile.v0
<missing>      8 minutes ago   CMD ["/bin/sh" "-c" "echo \"----------------…   0B        buildkit.dockerfile.v0
<missing>      8 minutes ago   CMD ["/bin/sh" "-c" "echo $MYPATH"]              0B        buildkit.dockerfile.v0
<missing>      8 minutes ago   EXPOSE map[80/tcp:{}]                            0B        buildkit.dockerfile.v0
<missing>      8 minutes ago   RUN /bin/sh -c yum -y install net-tools # bu…   217MB     buildkit.dockerfile.v0
<missing>      8 minutes ago   RUN /bin/sh -c yum -y install vim # buildkit     306MB     buildkit.dockerfile.v0
<missing>      8 minutes ago   WORKDIR /usr/local                               0B        buildkit.dockerfile.v0
<missing>      8 minutes ago   ENV MYPATH=/usr/local                            0B        buildkit.dockerfile.v0
<missing>      8 minutes ago   MAINTAINER bin<123456@qq.com>                    0B        buildkit.dockerfile.v0
<missing>      2 years ago     /bin/sh -c #(nop)  CMD ["/bin/bash"]             0B        
<missing>      2 years ago     /bin/sh -c #(nop)  LABEL org.label-schema.sc…   0B        
<missing>      2 years ago     /bin/sh -c #(nop) ADD file:b3ebbe8bd304723d4…   204MB     
```

### 5.发布镜像到dockerhub

首先，你要在dockerhub官网上去注册一个账号

其次，就是利用docker push命令

`docker push [OPTIONS] NAME[:TAG]`

其中，`OPTIONS` 是可选的参数，`NAME` 是要推送的镜像的名称，`TAG` 是镜像的标签。

下面是一些常用的选项：

- `-a, --all-tags`：推送镜像的所有标签。
- `--disable-content-trust`：禁用内容信任，允许推送非签名的镜像。
- `--quiet, -q`：只显示推送进度。

如果要推到某个用户的账号下，就要写他的用户名

**docker push username/test:1.0**

一般我们要往dockerhub上发送镜像一般要带上自己的仓库名（用户名）不然会被拒绝

```shell
The push refers to repository [docker.io/library/my_centos]
3013d2d8a444: Preparing 
2fa763d61868: Preparing 
5f70bf18a086: Preparing 
174f56854903: Preparing 
denied: requested access to the resource is denied

```



接下来就可以去dockerhub上看到自己的镜像了
